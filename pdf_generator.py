# pdf_generator.py - PDF generation utilities for JEE Seat Finder

from fpdf import FPDF
import datetime
import pandas as pd


class ShortlistPDF(FPDF):
    """Custom PDF class for generating shortlist reports"""
    
    def __init__(self, username):
        super().__init__()
        self.username = username
        self.set_auto_page_break(auto=True, margin=15)
    
    def header(self):
        """Add header to each page"""
        # Logo/Title
        self.set_font('Arial', 'B', 16)
        self.set_text_color(102, 126, 234)  # Blue color
        self.cell(0, 15, 'ðŸŽ“ JEE Seat Finder - My Shortlist', 0, 1, 'C')
        
        # User info
        self.set_font('Arial', '', 12)
        self.set_text_color(0, 0, 0)  # Black color
        self.cell(0, 10, f'Student: {self.username}', 0, 1, 'C')
        
        # Date
        current_date = datetime.datetime.now().strftime("%B %d, %Y")
        self.cell(0, 10, f'Generated on: {current_date}', 0, 1, 'C')
        self.ln(5)

    def footer(self):
        """Add footer to each page"""
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(128, 128, 128)  # Gray color
        self.cell(0, 10, f'Page {self.page_no()} | Generated by JEE Seat Finder', 0, 0, 'C')

    def add_summary_section(self, df):
        """Add summary section with key statistics"""
        self.set_font('Arial', 'B', 12)
        self.set_text_color(0, 0, 0)
        self.cell(0, 10, f'Total Options in Shortlist: {len(df)}', 0, 1, 'L')
        self.ln(5)

    def add_shortlist_table(self, df):
        """Add the main shortlist table"""
        # Table setup
        self.set_font('Arial', 'B', 9)
        self.set_fill_color(102, 126, 234)  # Blue background
        self.set_text_color(255, 255, 255)  # White text
        
        # Column widths optimized for A4 page
        col_widths = [12, 35, 45, 20, 18, 15, 20, 25]
        headers = ['Priority', 'Institute', 'Program', 'Closing Rank', 'Seat Type', 'Quota', 'Gender', 'Notes']
        
        # Print headers
        for i, header in enumerate(headers):
            self.cell(col_widths[i], 8, header, 1, 0, 'C', True)
        self.ln()
        
        # Table rows
        self.set_font('Arial', '', 8)
        self.set_text_color(0, 0, 0)  # Black text
        fill = False
        
        for _, row in df.iterrows():
            # Check if we need a new page
            if self.get_y() > 250:  # Near bottom of page
                self.add_page()
                # Re-add headers on new page
                self.set_font('Arial', 'B', 9)
                self.set_fill_color(102, 126, 234)
                self.set_text_color(255, 255, 255)
                for i, header in enumerate(headers):
                    self.cell(col_widths[i], 8, header, 1, 0, 'C', True)
                self.ln()
                self.set_font('Arial', '', 8)
                self.set_text_color(0, 0, 0)
            
            # Alternate row colors
            if fill:
                self.set_fill_color(240, 240, 240)  # Light gray
            else:
                self.set_fill_color(255, 255, 255)  # White
            
            # Prepare row data with proper truncation
            row_data = [
                str(int(row.get('priority_order', 0))),
                self._truncate_text(str(row.get('institute', '')), 30),
                self._truncate_text(str(row.get('program', '')), 35),
                f"{int(row.get('closing_rank', 0)):,}",
                self._truncate_text(str(row.get('seat_type', '')), 15),
                str(row.get('quota', '')),
                self._truncate_text(str(row.get('gender', '')), 15),
                self._truncate_text(str(row.get('notes', '')), 20)
            ]
            
            # Print row
            for i, cell_data in enumerate(row_data):
                self.cell(col_widths[i], 7, cell_data, 1, 0, 'C', fill)
            self.ln()
            fill = not fill  # Alternate fill

    def add_statistics_section(self, df):
        """Add summary statistics at the bottom"""
        if len(df) == 0:
            return
            
        self.ln(10)
        self.set_font('Arial', 'B', 12)
        self.set_text_color(102, 126, 234)
        self.cell(0, 8, 'Summary Statistics', 0, 1, 'L')
        self.ln(2)
        
        self.set_font('Arial', '', 10)
        self.set_text_color(0, 0, 0)
        
        # Calculate statistics
        avg_rank = df['closing_rank'].mean()
        min_rank = df['closing_rank'].min()
        max_rank = df['closing_rank'].max()
        
        # Rank statistics
        self.cell(0, 6, f'â€¢ Average Closing Rank: {int(avg_rank):,}', 0, 1, 'L')
        self.cell(0, 6, f'â€¢ Best Rank (Lowest): {int(min_rank):,}', 0, 1, 'L')
        self.cell(0, 6, f'â€¢ Highest Rank: {int(max_rank):,}', 0, 1, 'L')
        self.ln(3)
        
        # Institute breakdown
        institute_counts = df['institute'].value_counts().head(5)
        self.set_font('Arial', 'B', 10)
        self.cell(0, 6, 'Top Institutes in your shortlist:', 0, 1, 'L')
        self.set_font('Arial', '', 9)
        for institute, count in institute_counts.items():
            self.cell(0, 5, f'  â€¢ {institute}: {count} option{"s" if count > 1 else ""}', 0, 1, 'L')
        
        self.ln(3)
        
        # Seat type breakdown
        seat_type_counts = df['seat_type'].value_counts()
        self.set_font('Arial', 'B', 10)
        self.cell(0, 6, 'Seat Types Distribution:', 0, 1, 'L')
        self.set_font('Arial', '', 9)
        for seat_type, count in seat_type_counts.items():
            self.cell(0, 5, f'  â€¢ {seat_type}: {count} option{"s" if count > 1 else ""}', 0, 1, 'L')

    def _truncate_text(self, text, max_length):
        """Truncate text to fit in table cells"""
        if len(text) > max_length:
            return text[:max_length-3] + "..."
        return text


def generate_shortlist_pdf(df, username):
    """
    Generate a well-formatted PDF from shortlist DataFrame
    
    Args:
        df (pandas.DataFrame): Shortlist data
        username (str): User's name for the report
    
    Returns:
        bytes: PDF file as bytes
    """
    try:
        # Create PDF instance
        pdf = ShortlistPDF(username)
        pdf.add_page()
        
        # Add sections
        pdf.add_summary_section(df)
        pdf.add_shortlist_table(df)
        pdf.add_statistics_section(df)
        
        # Return PDF as bytes
        return pdf.output(dest='S').encode('latin1')
        
    except Exception as e:
        raise Exception(f"PDF generation failed: {str(e)}")


def generate_search_results_pdf(df, username, filters_applied=None):
    """
    Generate PDF for search results (optional feature)
    
    Args:
        df (pandas.DataFrame): Search results data
        username (str): User's name
        filters_applied (dict): Applied filters information
    
    Returns:
        bytes: PDF file as bytes
    """
    try:
        pdf = FPDF()
        pdf.add_page()
        
        # Header
        pdf.add_font("DejaVu", "", "DejaVuSans.ttf", uni=True)
        pdf.set_font('DejaVu', 'B', 16)
        pdf.set_text_color(102, 126, 234)
        pdf.cell(0, 15, 'ðŸŽ“ JEE Seat Finder - Search Results', 0, 1, 'C')
        
        pdf.set_font('Arial', '', 12)
        pdf.set_text_color(0, 0, 0)
        pdf.cell(0, 10, f'User: {username}', 0, 1, 'C')
        
        current_date = datetime.datetime.now().strftime("%B %d, %Y")
        pdf.cell(0, 10, f'Generated on: {current_date}', 0, 1, 'C')
        pdf.ln(10)
        
        # Results summary
        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, f'Found {len(df)} matching programs', 0, 1, 'L')
        
        # Add filters information if provided
        if filters_applied:
            pdf.ln(5)
            pdf.set_font('Arial', 'B', 10)
            pdf.cell(0, 8, 'Applied Filters:', 0, 1, 'L')
            pdf.set_font('Arial', '', 9)
            for filter_name, filter_value in filters_applied.items():
                if filter_value:
                    pdf.cell(0, 5, f'â€¢ {filter_name}: {filter_value}', 0, 1, 'L')
        
        pdf.ln(10)
        
        # Table with limited columns for search results
        pdf.set_font('Arial', 'B', 8)
        pdf.set_fill_color(102, 126, 234)
        pdf.set_text_color(255, 255, 255)
        
        col_widths = [40, 50, 25, 20, 20, 25]
        headers = ['Institute', 'Program', 'Closing Rank', 'Seat Type', 'Quota', 'Gender']
        
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 8, header, 1, 0, 'C', True)
        pdf.ln()
        
        # Add rows (limit to first 50 for readability)
        pdf.set_font('Arial', '', 7)
        pdf.set_text_color(0, 0, 0)
        
        for idx, (_, row) in enumerate(df.head(50).iterrows()):
            if idx % 2 == 0:
                pdf.set_fill_color(240, 240, 240)
            else:
                pdf.set_fill_color(255, 255, 255)
            
            row_data = [
                str(row.get('Institute', ''))[:35],
                str(row.get('Academic Program Name', ''))[:40],
                f"{int(row.get('Closing Rank', 0)):,}",
                str(row.get('Seat Type', ''))[:15],
                str(row.get('Quota', '')),
                str(row.get('Gender', ''))[:20]
            ]
            
            for i, cell_data in enumerate(row_data):
                pdf.cell(col_widths[i], 6, cell_data, 1, 0, 'C', True)
            pdf.ln()
        
        if len(df) > 50:
            pdf.ln(5)
            pdf.set_font('Arial', 'I', 9)
            pdf.cell(0, 5, f'Note: Showing first 50 results. Total results: {len(df)}', 0, 1, 'L')
        
        return pdf.output(dest='S').encode('latin1')
        
    except Exception as e:
        raise Exception(f"Search results PDF generation failed: {str(e)}")


def validate_dataframe_for_pdf(df):
    """
    Validate that the DataFrame has required columns for PDF generation
    
    Args:
        df (pandas.DataFrame): DataFrame to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    required_columns = ['institute', 'program', 'closing_rank']
    return all(col in df.columns for col in required_columns)
